request = require('request')
wolfram = require('wolfram-alpha').createClient("36P8G3-KWH3VUU3HP")

String.prototype.replaceAt=function(index, character) {
    return this.substr(0, index) + character + this.substr(index+character.length);
}

var assocify = function(s, k = 4){
    let n = s.toString(2)
    zeros = ""
    for (i = 0; i < k; i++)
        zeros += "0"
    return zeros.substr(n.length) + n
}
function unique(arr) {
    var result = [];

    nextInput:
        for (var i = 0; i < arr.length; i++) {
            var str = arr[i]; // для каждого элемента
            for (var j = 0; j < result.length; j++) { // ищем, был ли он уже?
                if (result[j] == str) continue nextInput; // если да, то следующий
            }
            result.push(str);
        }

    return result;
}

/*
* Генератор функции с фиктивными переменными
* */
var generate_dummy = function (dummies = 0){
    let object = {
        truthTable: {
            array: new Array(16),
            assoc: {
                '0000': 2, '0001': 2, '0010': 2, '0011': 2,
                '0100': 2, '0101': 2, '0110': 2, '0111': 2,
                '1000': 2, '1001': 2, '1010': 2, '1011': 2,
                '1100': 2, '1101': 2, '1110': 2, '1111': 2
            }
        },
        dummy: {}
    }
    switch (dummies){
        case 0:
        {
            for (let i = 0; i < 16; i++) {
                let bit = Math.round(Math.random())
                object.truthTable.array[i] = bit
                object.truthTable.assoc[assocify(i)] = bit
            }
            object.dummy = find_dummy(object.truthTable.array)
            if (object.dummy.some((x) => {return x})){
                console.log("dummy!")
                return generate_dummy()
            }
            break
        }
        case 1: // Одна и более фиктивных переменных
        {
            var whosdummy = Math.round(Math.random()*3)
            switch (whosdummy){
                case 0: { // Фиктивная Z
                    for (let i = 0; i < 8; i++) {
                        let bit = Math.round(Math.random())
                        let j = i*2

                        object.truthTable.array[ j ] = bit
                        object.truthTable.array[j+1] = bit

                        object.truthTable.assoc[assocify(j)] = bit
                        object.truthTable.assoc[assocify(j+1)] = bit
                    }
                    break
                }
                case 1: { // Фиктивная Y
                    for (var i = 0; i < 16; i+=4){
                        for (var j = 0; j < 2; j++){
                            let bit = Math.round(Math.random())
                            object.truthTable.array[ i+j ] = bit
                            object.truthTable.array[i+j+2] = bit

                            object.truthTable.assoc[assocify(i+j)]   = bit
                            object.truthTable.assoc[assocify(i+j+2)] = bit
                        }
                    }
                    break
                }
                case 2: { // Фиктивная X
                    for (let i = 0; i < 4; i++) {
                        let bit = Math.round(Math.random())
                        object.truthTable.array[ i ] = bit
                        object.truthTable.array[i+4] = bit

                        object.truthTable.assoc[assocify(i)]   = bit
                        object.truthTable.assoc[assocify(i+4)] = bit
                    }
                    for (let i = 8; i < 12; i++) {
                        let bit = Math.round(Math.random())
                        object.truthTable.array[ i ] = bit
                        object.truthTable.array[i+4] = bit

                        object.truthTable.assoc[assocify(i)]   = bit
                        object.truthTable.assoc[assocify(i+4)] = bit
                    }
                    break
                }
                case 3: { // Фиктивная T
                    for (let i = 0; i < 8; i++) {
                        let bit = Math.round(Math.random())
                        object.truthTable.array[ i ] = bit
                        object.truthTable.array[i+8] = bit

                        object.truthTable.assoc[assocify(i)]   = bit
                        object.truthTable.assoc[assocify(i+8)] = bit
                    }
                    break
                }
            }
            object.dummy = find_dummy(object.truthTable.array)
        }
    }
    object.dummies_number  = object.dummy.reduce((sum, current) => {return current ? sum+1 : sum},0)
    return object
}

/*
* Функция поиска фиктивных переменных в массиве.
* Принимает массив значний функции
* Возвращает массив [t,x,y,z], где на месте буквы стоит булевое true или false
* */
var find_dummy = function (array) {
    half_array = 8
    // [t, x, y, z]
    dummy = [true, true, true, true]
    //Проверяем фиктивность z
    for (let i = 0; i < half_array; i++){
        j = i*2
        if (array[j+1] != array[j])
            dummy[3] = false
    }
    //Проверяем фиктивность y
    for (let i = 0; i < 16; i+=4){
        for (var j = 0; j < 2; j++){
            if (array[i+j] != array[i+j+2])
                dummy[2] = false
        }
    }
    // Проверяем фиктивность х
    for (let i = 0; i < 4; i++)
        if (array[ i ] != array[i+4])
            dummy[1] = false
    for (let i = 8; i < 12; i++)
        if (array[ i ] != array[i+4])
            dummy[1] = false

    // Проверяем фиктивноасть t
    for (let i = 0; i < 8; i++) {
        if (array[i] != array [i+8])
            dummy[0] = false
    }

    return dummy
}

/*
* Генератор функции с выражениями
* */
var generate_expression = function (cb) {
    operands    = ['X', 'Y', 'Z', 'T']
    operators   = ['and', 'or', 'xor', 'implies']
    n_operands = 5
    var callbacks = 0
    var result = "("
    let object = {
        expression: "",
        truthTable: {
            array: [],
            assoc: {
                '0000': 2, '0001': 2,
                '0010': 2, '0011': 2,
                '0100': 2, '0101': 2,
                '0110': 2, '0111': 2,
                '1000': 2, '1001': 2,
                '1010': 2, '1011': 2,
                '1100': 2, '1101': 2,
                '1110': 2, '1111': 2
            }
        }
    }

    function A(){
        callbacks++;
        if (callbacks == 1)
            cb(object)
    }

    for (i=0; i<n_operands*2-1; i++){
        if (i % 2){
            r = Math.ceil(Math.random()*operators.length-1)
            result += operators[r]+" "
        } else {
            not = Math.round(Math.random()) ? "not " : ""
            r = Math.ceil(Math.random()*operands.length-1)
            result += not+operands[r]+" "
            if (i == 4)
                result += ") "
        }
    }
    console.log(result)
    for (i=0; i<operands.length; i++){
        if (!result.includes(operands[i])){
            return generate_expression(cb)
        }
    }

    wolfram.query("truth table "+result, function (err, data) {
        if (err) {
            cb(err);
            console.log(err)
            return;
        }
        try{
            row = data[1].subpods[0].text.split("\n")
        } catch (e){
            console.log(e)
            return false
        }

        for (var i=row.length-1, k = 0; i>0; i--, k++) {
            if (row[i].slice(-2).trim() == "T") {
                object.truthTable.assoc[assocify(k)] = 1
                object.truthTable.array.push(1)
            } else {
                object.truthTable.assoc[assocify(k)] = 0
                object.truthTable.array.push(0)
            }
        }
        if (object.truthTable.array.length != 16)
            return generate_expression(cb)
        object.expression = row[i].slice(16)
        A()
    });
}

/*
* Генератор функции с ДНФ
* */
var generate_dnf = function(cb){
    let object = {
        truthTable: {
            array: new Array(16),
            assoc: {
                '0000': 2, '0001': 2, '0010': 2, '0011': 2,
                '0100': 2, '0101': 2, '0110': 2, '0111': 2,
                '1000': 2, '1001': 2, '1010': 2, '1011': 2,
                '1100': 2, '1101': 2, '1110': 2, '1111': 2
            }
        },
        pdnf: [],
        dnf: []
    }

    let f_stringed = [Math.round(Math.random()*65536)]
    console.log(f_stringed, assocify(f_stringed[0], 16))
    f_stringed.push(assocify(f_stringed[0], 16))

    for (var i = 0; i < 16; i++){
        var j = (i >>> 0).toString(2);
        var disjunt = ""
        if (parseInt(f_stringed[1][i])){
            switch (j.length){
                case 1:{
                    disjunt = "!t!x!y"
                    disjunt += parseInt(j) ? "z" : "!z"
                    break
                }
                case 2: {
                    disjunt = "!t!x"
                    disjunt += parseInt(j[0]) ? "y" : "!y"
                    disjunt += parseInt(j[1]) ? "z" : "!z"
                    break
                }
                case 3: {
                    disjunt = "!t"
                    disjunt += parseInt(j[0]) ? "x" : "!x"
                    disjunt += parseInt(j[1]) ? "y" : "!y"
                    disjunt += parseInt(j[2]) ? "z" : "!z"
                    break
                }
                case 4: {
                    disjunt += parseInt(j[0]) ? "t" : "!t"
                    disjunt += parseInt(j[1]) ? "x" : "!x"
                    disjunt += parseInt(j[2]) ? "y" : "!y"
                    disjunt += parseInt(j[3]) ? "z" : "!z"
                }
            }
            object.pdnf.push(disjunt)
            object.truthTable.array[i] = 1
            object.truthTable.assoc[assocify(i)] = 1
        } else {
            object.truthTable.array[i] = 0
            object.truthTable.assoc[assocify(i)] = 0
        }
        console.log(i, assocify(i), object.truthTable.array[i], object.truthTable.assoc[assocify(i)])
    }
    //dnf 36537th Boolean function of t,x,y,z
    wolfram.query("dnf "+f_stringed[0]+"th Boolean function of t,x,y,z", function (err, data) {
        if (err) {
            cb(err);
            console.log(err);
            return;
        }
        if (!data[0].subpods[1])
            return generate_dnf(cb)
        if (!data[0].subpods[1].text.includes("AND"))
            return generate_dnf(cb)
        object.dnf = data[0].subpods[1]
        object.dnf.arr = object.dnf.text.split(" OR  ")
        for (i = 0; i < object.dnf.arr.length; i++){
            //Преобразуем все энды в пустоту
            object.dnf.arr[i] = object.dnf.arr[i].replace(/ AND  /g, "");
            //Преобразуем (NOT X) в !x
            object.dnf.arr[i] = object.dnf.arr[i].replace(/\(NOT (\w)\)/g,"!$1").toLowerCase()
            object.dnf.arr[i] = object.dnf.arr[i].replace(/\(|\)/g,"")
        }
        object.truthTable.array = object.truthTable.array.reverse()
        for (i = 0; i < 16; i++)
            object.truthTable.assoc[assocify(i)] = object.truthTable.array[i]
        cb(object)
    });
}

/*
* Генератор монотонной функции
* */
var generate_monotonic = function (b = true) {

    // ass_vas is string
    function childs(ass_val){
        let stack = []
        ass_val.split("").forEach((x,i) => {
            if (x == "0"){
                let next = ass_val
                next = next.replaceAt(i, "1") // Проверяем со следующим.
                stack.push(next)
            }
        })
        stack.forEach((x)=>{
            childs(x).forEach(y => { stack.push(y) })
        })
        return unique(stack)
    }

    let object = {
        truthTable: {
            array: new Array(16),
            assoc: {
                '0000': 0, '0001': 0, '0010': 0, '0011': 0,
                '0100': 0, '0101': 0, '0110': 0, '0111': 0,
                '1000': 0, '1001': 0, '1010': 0, '1011': 0,
                '1100': 0, '1101': 0, '1110': 0, '1111': 0
            }
        },
        monotonic: true
    }
    let probability = {'0000': 0.05, '1111': 0.1,
                       '0001': 0.33, '0010': 0.33, '0100': 0.33, '1000': 0.33,
                       '0011': 0.50, '0101': 0.50, '0110': 0.50, '1001': 0.50, '1010': 0.5, '1100': 0.5,
                       '0111': 0.40, '1011': 0.40, '1101': 0.50, '1110': 0.50
                      }
    for (let i = 0; i < 16; i++){
        let p = Math.random(), j = assocify(i)
        if (p <= probability[j] && object.truthTable.assoc[i] != 1){
            //console.log(p, probability[j], p <= probability[j], j)
            object.truthTable.assoc[j] = 1
            childs(j).forEach(x => {
                object.truthTable.assoc[x] = 1
            })
        }
    }
    for (x in object.truthTable.assoc){
        object.truthTable.array[parseInt(x,2)] = object.truthTable.assoc[x]
    }

    if (!b){
        while (monotonic(object.truthTable.assoc)){
            let p = Math.round(Math.random()*15)
            object.truthTable.array[p]           = (object.truthTable.array[p] == 1)           ? 0 : 1
            object.truthTable.assoc[assocify(p)] = (object.truthTable.assoc[assocify(p)] == 1) ? 0 : 1
        }
        object.monotonic = false
    }
    return object
}

/*
* Генератор самодвойственной функции
* */
var generate_selfdual = function (b = true){
    let object = {
        truthTable: {
            array: new Array(16),
            assoc: {
                '0000': 2, '0001': 2,
                '0010': 2, '0011': 2,
                '0100': 2, '0101': 2,
                '0110': 2, '0111': 2,
                '1000': 2, '1001': 2,
                '1010': 2, '1011': 2,
                '1100': 2, '1101': 2,
                '1110': 2, '1111': 2
            }
        },
        selfdual: true
    }
    if (b){
        for (let i = 0; i < 8; i++){
            let bit = Math.round(Math.random())
            object.truthTable.array[  i ] = bit
            object.truthTable.array[15-i] = bit ? 0 : 1
            object.truthTable.assoc[assocify(i)] = bit
            object.truthTable.assoc[assocify(15-i)] = bit ? 0 : 1
        }
    } else {
        let pos = Math.round(Math.random()*7) // В каком месте нарушится самодвойственность
        for (let i = 0; i < 8; i++){
            let bit = Math.round(Math.random())
            if (i != pos) {
                object.truthTable.array[  i ] = bit
                object.truthTable.array[15-i] = bit ? 0 : 1
                object.truthTable.assoc[assocify(i)] = bit
                object.truthTable.assoc[assocify(15-i)] = bit ? 0 : 1
            } else {
                object.truthTable.array[  i ] = bit
                object.truthTable.array[15-i] = bit
                object.truthTable.assoc[assocify(i)] = bit
                object.truthTable.assoc[assocify(15-i)] = bit
            }
        }
        object.vertexes = [assocify(pos), assocify(15-pos)]
        object.selfdual = false
    }
    return object
}

var generate_jegalkin = function(cb){

    let Arrays = []

    //let object = {
    //    jegalkin: "",
    //    truthTable: {
    //        array: [],
    //        assoc: {
    //            '0000': 2, '0001': 2,
    //            '0010': 2, '0011': 2,
    //            '0100': 2, '0101': 2,
    //            '0110': 2, '0111': 2,
    //            '1000': 2, '1001': 2,
    //            '1010': 2, '1011': 2,
    //            '1100': 2, '1101': 2,
    //            '1110': 2, '1111': 2
    //        }
    //    }
    //}

    let letters = ["T", "X", "Y", "Z"]
    let q = "", r = 0, c = 0, t
    r = Math.ceil(Math.random()*4)
    console.log("r",r)
    while (letters.length && c < r ){
        t = Math.floor(Math.random()*letters.length)
        q += letters[t] + " xor "
        letters.splice(t, 1);
        c++
    }
    console.log(letters)
    q = q.slice(0, -4)
    object.jegalkin = q
    letters.forEach( x => { q+=" xor ("+x+" and (not "+x+"))" })
    console.log(q)
    wolfram.query("truth table "+q, function (err, data) {
        if (err){
            //
        }
        try{
            row = data[1].subpods[0].text.split("\n")
        } catch (e){
            console.log(e)
            cb(false)
        }
        for (var i=row.length-1, k = 0; i>0; i--, k++) {
            if (row[i].slice(-2).trim() == "T") {
                object.truthTable.assoc[assocify(k)] = 1
                object.truthTable.array.push(1)
            } else {
                object.truthTable.assoc[assocify(k)] = 0
                object.truthTable.array.push(0)
            }
        }
        cb(object)
    })
}

var generate_jegalkin_alt = function(cb){

    let queries = [
        "X xor Y xor Z xor T",

        "X xor (Y and (not Y)) xor (Z and (not Z)) xor (T and (not T))",
        "Y xor (X and (not X)) xor (Z and (not Z)) xor (T and (not T))",
        "Z xor (Y and (not Y)) xor (X and (not X)) xor (T and (not T))",
        "T xor (Y and (not Y)) xor (Z and (not Z)) xor (X and (not X))",

        "X xor Y xor (Z and (not Z)) xor (T and (not T))",
        "X xor Z xor (Y and (not Y)) xor (T and (not T))",
        "X xor T xor (Y and (not Y)) xor (Z and (not Z))",
        "Y xor Z xor (X and (not X)) xor (T and (not T))",
        "Y xor T xor (X and (not X)) xor (Z and (not Z))",
        "Z xor T xor (X and (not X)) xor (Y and (not Y))",

        "X xor Y xor Z xor (T and (not T))",
        "X xor Y xor T xor (Z and (not Z))",
        "X xor T xor Z xor (Y and (not Y))",
        "Y xor Z xor T xor (X and (not X))"]

    let c = 0, tt = []
    function A(wolfram_tt){
        tt.push(wolfram_tt)
        c++
        if (c == queries.length){ cb(tt) }
    }

    queries.forEach(x => {
        wolfram.query("truth table "+x, function (err, data) {
            if (err){
                //
            }
            try{
                row = data[1].subpods[0].text.split("\n")
            } catch (e){
                console.log(e)
                cb(false)
            }
            console.log("recieved result of "+x)
            let wolfram_tt = []
            for (var i=row.length-1, k = 0; i>0; i--, k++) {
                if (row[i].slice(-2).trim() == "T") {
                    //object.truthTable.assoc[assocify(k)] = 1
                    wolfram_tt.push(1)
                } else {
                    //object.truthTable.assoc[assocify(k)] = 0
                    wolfram_tt.push(0)
                }
            }
            A(wolfram_tt)
        })
    })
}

var monotonic = function (assoc) {
    for (let i = 0; i < 16; i++){
        let assoced = assocify(i)
        for (let j = 0; j<4; j++){
            // Если это нуль
            if (!parseInt(assoced[j])) {
                //console.log("analyzing "+assoced)
                let next = assoced
                next = next.replaceAt(j, "1") // Проверяем со следующим.
                //console.log(assoced, assoc[assoced])
                //console.log(next, assoc[next])
                if (assoc[next]<assoc[assoced]){
                    return false
                }
            }
        }
    }
    return true
}

var selfdual = function (array) {
    for (let i = 0; i < 8; i++){
        if (array[i] == array[15-i]){
            return false
        }
    }
    return true
}



module.exports.generate_expression = generate_expression
module.exports.generate_dummy = generate_dummy
module.exports.generate_dnf = generate_dnf
module.exports.generate_selfdual = generate_selfdual
module.exports.generate_monotonic = generate_monotonic
module.exports.generate_jegalkin = generate_jegalkin_alt
module.exports.monotonic = monotonic
module.exports.assocify = assocify
module.exports.selfdual = selfdual
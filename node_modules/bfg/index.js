request = require('request')
wolfram = require('wolfram-alpha').createClient("36P8G3-KWH3VUU3HP")

String.prototype.replaceAt=function(index, character) {
    return this.substr(0, index) + character + this.substr(index+character.length);
}

var assocify = function(s, k = 4){
    let n = s.toString(2)
    zeros = ""
    for (i = 0; i < k; i++)
        zeros += "0"
    return zeros.substr(n.length) + n
}

var generate_dummy = function (dummies = 0){
    let object = {
        truthTable: {
            array: new Array(16),
            assoc: {
                '0000': 2, '0001': 2, '0010': 2, '0011': 2,
                '0100': 2, '0101': 2, '0110': 2, '0111': 2,
                '1000': 2, '1001': 2, '1010': 2, '1011': 2,
                '1100': 2, '1101': 2, '1110': 2, '1111': 2
            }
        },
        dummy: {}
    }
    switch (dummies){
        case 0:
        {
            for (let i = 0; i < 16; i++) {
                let bit = Math.round(Math.random())
                object.truthTable.array[i] = bit
                object.truthTable.assoc[assocify(i)] = bit
            }
            object.dummy = find_dummy(object.truthTable.array)
            if (object.dummy.some((x) => {return x})){
                console.log("dummy!")
                return generate_dummy()
            }
            break
        }
        case 1: // Одна и более фиктивных переменных
        {
            var whosdummy = Math.round(Math.random()*3)
            switch (whosdummy){
                case 0: { // Фиктивная Z
                    for (let i = 0; i < 8; i++) {
                        let bit = Math.round(Math.random())
                        let j = i*2

                        object.truthTable.array[ j ] = bit
                        object.truthTable.array[j+1] = bit

                        object.truthTable.assoc[assocify(j)] = bit
                        object.truthTable.assoc[assocify(j+1)] = bit
                    }
                    break
                }
                case 1: { // Фиктивная Y
                    for (var i = 0; i < 16; i+=4){
                        for (var j = 0; j < 2; j++){
                            let bit = Math.round(Math.random())
                            object.truthTable.array[ i+j ] = bit
                            object.truthTable.array[i+j+2] = bit

                            object.truthTable.assoc[assocify(i+j)]   = bit
                            object.truthTable.assoc[assocify(i+j+2)] = bit
                        }
                    }
                    break
                }
                case 2: { // Фиктивная X
                    for (let i = 0; i < 4; i++) {
                        let bit = Math.round(Math.random())
                        object.truthTable.array[ i ] = bit
                        object.truthTable.array[i+4] = bit

                        object.truthTable.assoc[assocify(i)]   = bit
                        object.truthTable.assoc[assocify(i+4)] = bit
                    }
                    for (let i = 8; i < 12; i++) {
                        let bit = Math.round(Math.random())
                        object.truthTable.array[ i ] = bit
                        object.truthTable.array[i+4] = bit

                        object.truthTable.assoc[assocify(i)]   = bit
                        object.truthTable.assoc[assocify(i+4)] = bit
                    }
                    break
                }
                case 3: { // Фиктивная T
                    for (let i = 0; i < 8; i++) {
                        let bit = Math.round(Math.random())
                        object.truthTable.array[ i ] = bit
                        object.truthTable.array[i+8] = bit

                        object.truthTable.assoc[assocify(i)]   = bit
                        object.truthTable.assoc[assocify(i+4)] = bit
                    }
                    break
                }
            }
            object.dummy = find_dummy(object.truthTable.array)
        }
    }
    object.dummies_number  = object.dummy.reduce((sum, current) => {return current ? sum+1 : sum},0)
    return object
}

/*
* Функция поиска фиктивных переменных в массиве.
* Принимает массив значний функции
* Возвращает массив [t,x,y,z], где на месте буквы стоит булевое true или false
* */
var find_dummy = function (array) {
    half_array = 8
    // [t, x, y, z]
    dummy = [true, true, true, true]
    //Проверяем фиктивность z
    for (let i = 0; i < half_array; i++){
        j = i*2
        if (array[j+1] != array[j])
            dummy[3] = false
    }
    //Проверяем фиктивность y
    for (let i = 0; i < 16; i+=4){
        for (var j = 0; j < 2; j++){
            if (array[i+j] != array[i+j+2])
                dummy[2] = false
        }
    }
    // Проверяем фиктивность х
    for (let i = 0; i < 4; i++)
        if (array[ i ] != array[i+4])
            dummy[1] = false
    for (let i = 8; i < 12; i++)
        if (array[ i ] != array[i+4])
            dummy[1] = false

    // Проверяем фиктивноасть t
    for (let i = 0; i < 8; i++) {
        if (array[i] != array [i+8])
            dummy[0] = false
    }

    return dummy
}

var generate_expression = function (cb) {
    operands    = ['X', 'Y', 'Z', 'T']
    operators   = ['and', 'or', 'xor', 'implies']
    n_operands = 5
    var callbacks = 0
    var result = "("
    let object = {
        expression: "",
        truthTable: {
            array: [],
            assoc: {
                '0000': 2, '0001': 2,
                '0010': 2, '0011': 2,
                '0100': 2, '0101': 2,
                '0110': 2, '0111': 2,
                '1000': 2, '1001': 2,
                '1010': 2, '1011': 2,
                '1100': 2, '1101': 2,
                '1110': 2, '1111': 2
            }
        }
    }

    function A(){
        callbacks++;
        if (callbacks == 1)
            cb(object)
    }

    for (i=0; i<n_operands*2-1; i++){
        if (i % 2){
            r = Math.ceil(Math.random()*operators.length-1)
            result += operators[r]+" "
        } else {
            not = Math.round(Math.random()) ? "not " : ""
            r = Math.ceil(Math.random()*operands.length-1)
            result += not+operands[r]+" "
            if (i == 4)
                result += ") "
        }
    }
    console.log(result)
    for (i=0; i<operands.length; i++){
        if (!result.includes(operands[i])){
            return generate_expression(cb)
        }
    }

    wolfram.query("truth table "+result, function (err, data) {
        if (err) {
            cb(err);
            console.log(err)
            return;
        }
        try{
            row = data[1].subpods[0].text.split("\n")
        } catch (e){
            console.log(e)
            return false
        }

        for (var i=row.length-1, k = 0; i>0; i--, k++) {
            if (row[i].slice(-2).trim() == "T") {
                object.truthTable.assoc[assocify(k)] = 1
                object.truthTable.array.push(1)
            } else {
                object.truthTable.assoc[assocify(k)] = 0
                object.truthTable.array.push(0)
            }
        }
        if (object.truthTable.array.length != 16)
            return generate_expression(cb)
        object.expression = row[i].slice(16)
        A()
    });
}

var generate_dnf = function(cb){
    let object = {
        truthTable: {
            array: new Array(16),
            assoc: {
                '0000': 2, '0001': 2, '0010': 2, '0011': 2,
                '0100': 2, '0101': 2, '0110': 2, '0111': 2,
                '1000': 2, '1001': 2, '1010': 2, '1011': 2,
                '1100': 2, '1101': 2, '1110': 2, '1111': 2
            }
        },
        pdnf: [],
        dnf: []
    }

    let f_stringed = [Math.round(Math.random()*65536)]
    console.log(f_stringed, assocify(f_stringed[0], 16))
    f_stringed.push(assocify(f_stringed[0], 16))

    for (var i = 0; i < 16; i++){
        var j = (i >>> 0).toString(2);
        var disjunt = ""
        if (parseInt(f_stringed[1][i])){
            switch (j.length){
                case 1:{
                    disjunt = "!t!x!y"
                    disjunt += parseInt(j) ? "z" : "!z"
                    break
                }
                case 2: {
                    disjunt = "!t!x"
                    disjunt += parseInt(j[0]) ? "y" : "!y"
                    disjunt += parseInt(j[1]) ? "z" : "!z"
                    break
                }
                case 3: {
                    disjunt = "!t"
                    disjunt += parseInt(j[0]) ? "x" : "!x"
                    disjunt += parseInt(j[1]) ? "y" : "!y"
                    disjunt += parseInt(j[2]) ? "z" : "!z"
                    break
                }
                case 4: {
                    disjunt += parseInt(j[0]) ? "t" : "!t"
                    disjunt += parseInt(j[1]) ? "x" : "!x"
                    disjunt += parseInt(j[2]) ? "y" : "!y"
                    disjunt += parseInt(j[3]) ? "z" : "!z"
                }
            }
            object.pdnf.push(disjunt)
            object.truthTable.array[i] = 1
            object.truthTable.assoc[assocify(i)] = 1
        } else {
            object.truthTable.array[i] = 0
            object.truthTable.assoc[assocify(i)] = 0
        }
    }
    //dnf 36537th Boolean function of t,x,y,z
    wolfram.query("dnf "+f_stringed[0]+"th Boolean function of t,x,y,z", function (err, data) {
        if (err) {
            cb(err);
            console.log(err);
            return;
        }
        if (!data[0].subpods[1])
            return generate_dnf(cb)
        if (!data[0].subpods[1].text.includes("AND"))
            return generate_dnf(cb)
        object.dnf = data[0].subpods[1]
        object.dnf.arr = object.dnf.text.split(" OR  ")
        for (i = 0; i < object.dnf.arr.length; i++){
            //Преобразуем все энды в пустоту
            object.dnf.arr[i] = object.dnf.arr[i].replace(/ AND  /g, "");
            //Преобразуем (NOT X) в !x
            object.dnf.arr[i] = object.dnf.arr[i].replace(/\(NOT (\w)\)/g,"!$1").toLowerCase()
            object.dnf.arr[i] = object.dnf.arr[i].replace(/\(|\)/g,"")
        }
        object.truthTable.array = object.truthTable.array.reverse()
        cb(object)
    });
}

var monotonic = function (assoc) {
    for (let i = 0; i < 16; i++){
        let assoced = assocify(i)
        for (let j = 0; j<4; j++){
            // Если это нуль
            if (!parseInt(assoced[j])) {
                //console.log("analyzing "+assoced)
                let next = assoced
                next = next.replaceAt(j, "1") // Проверяем со следующим.
                //console.log(assoced, assoc[assoced])
                //console.log(next, assoc[next])
                if (assoc[next]<assoc[assoced]){
                    return false
                }
            }
        }
    }
    return true
}

module.exports.generate_expression = generate_expression
module.exports.generate_dummy = generate_dummy
module.exports.generate_dnf = generate_dnf
module.exports.monotonic = monotonic
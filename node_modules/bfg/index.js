request = require('request')
wolfram = require('wolfram-alpha').createClient("36P8G3-KWH3VUU3HP")

var generate = function (cb) {
    operands    = ['X', 'Y', 'Z', 'T']
    operators   = ['and', 'or', 'xor', 'implies']
    n_operands = 7
    var callbacks = 0
    var result = "("
    let object = {
        expression: "",
        truthTable: {
            array: [],
            image: ""
        },
        pdnf: [],
        dnf: {}
    }

    function A(){
        callbacks++;
        if (callbacks == 2)
            cb(object)
    }

    for (i=0; i<n_operands*2-1; i++){
        if (i % 2){
            r = Math.ceil(Math.random()*operators.length-1)
            result += operators[r]+" "
        } else {
            not = Math.round(Math.random()) ? "not " : ""
            r = Math.ceil(Math.random()*operands.length-1)
            result += not+operands[r]+" "
            if (i == 6)
                result += ") "
        }
    }
    console.log(result)
    for (i=0; i<operands.length; i++){
        if (!result.includes(operands[i])){
            return generate(cb)
        }
    }

    wolfram.query("truth table "+result, function (err, data) {
        if (err) {
            cb(err);
            console.log(err)
            return;
        }
        row = data[1].subpods[0].text.split("\n")
        object.truthTable.image = data[1].subpods[0].image
        for (i=row.length-1; i>0; i--) {
            var j = ((row.length - 1) - i >>> 0).toString(2);
            var disjunt = ""
            if (row[i].slice(-2).trim() == "T") {
                object.truthTable.array.push(1)
                switch (j.length){
                    case 1:{
                        disjunt = "!t!x!y"
                        disjunt += parseInt(j) ? "z" : "!z"
                        break
                    }
                    case 2: {
                        disjunt = "!t!x"
                        disjunt += parseInt(j[0]) ? "y" : "!y"
                        disjunt += parseInt(j[1]) ? "z" : "!z"
                        break
                    }
                    case 3: {
                        disjunt = "!t"
                        disjunt += parseInt(j[0]) ? "x" : "!x"
                        disjunt += parseInt(j[1]) ? "y" : "!y"
                        disjunt += parseInt(j[2]) ? "z" : "!z"
                        break
                    }
                    case 4: {
                        disjunt += parseInt(j[0]) ? "t" : "!t"
                        disjunt += parseInt(j[1]) ? "x" : "!x"
                        disjunt += parseInt(j[2]) ? "y" : "!y"
                        disjunt += parseInt(j[3]) ? "z" : "!z"
                    }
                }
                object.pdnf.push(disjunt)
            } else {
                object.truthTable.array.push(0)
            }
        }
        if (object.truthTable.array.length != 16)
            return generate(cb)
        object.expression = row[i].slice(16)

        A()
    });

    wolfram.query("dnf "+result, function (err, data) {
        if (err) {
            cb(err);
            console.log(err);
            return;
        }

        if (!data[0].subpods[1])
            return generate(cb)
        if (!data[0].subpods[1].text.includes("AND"))
            return generate(cb)
        object.dnf = data[0].subpods[1]

        A()
    });
}

module.exports.generate = generate
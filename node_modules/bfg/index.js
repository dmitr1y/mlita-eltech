request = require('request')
wolfram = require('wolfram-alpha').createClient("36P8G3-KWH3VUU3HP")

var assocify = function(s){
    let n = s.toString(2)
    return "0000".substr(n.length) + n
}

var generate_dummy = function (){
    let object = {
        truthTable: {
            array: new Array(16),
            assoc: {
                '0000': 2, '0001': 2, '0010': 2, '0011': 2,
                '0100': 2, '0101': 2, '0110': 2, '0111': 2,
                '1000': 2, '1001': 2, '1010': 2, '1011': 2,
                '1100': 2, '1101': 2, '1110': 2, '1111': 2
            }
        },
        dummy: {}
    }
    let dummies = Math.round(Math.random())
    console.log(dummies)
    switch (dummies){
        case 0:
        {
            for (let i = 0; i < 16; i++) {
                let bit = Math.round(Math.random())
                object.truthTable.array[i] = bit
                object.truthTable.assoc[assocify(i)] = bit
            }
            object.dummy = find_dummy(object.truthTable.array)
            if (object.dummy.some((x) => {return x})){
                console.log("dummy!")
                return generate_dummy()
            }
            break
        }
        case 1: // Одна и более фиктивных переменных
        {
            var whosdummy = Math.round(Math.random()*3)
            console.log(whosdummy+" is dummy")
            switch (whosdummy){
                case 0: { // Фиктивная Z
                    for (let i = 0; i < 8; i++) {
                        let bit = Math.round(Math.random())
                        let j = i*2

                        object.truthTable.array[ j ] = bit
                        object.truthTable.array[j+1] = bit

                        object.truthTable.assoc[assocify(j)] = bit
                        object.truthTable.assoc[assocify(j+1)] = bit
                    }
                    break
                }
                case 1: { // Фиктивная Y
                    for (var i = 0; i < 16; i+=4){
                        for (var j = 0; j < 2; j++){
                            let bit = Math.round(Math.random())
                            object.truthTable.array[ i+j ] = bit
                            object.truthTable.array[i+j+2] = bit

                            object.truthTable.assoc[assocify(i+j)]   = bit
                            object.truthTable.assoc[assocify(i+j+2)] = bit
                        }
                    }
                    break
                }
                case 2: { // Фиктивная X
                    for (let i = 0; i < 4; i++) {
                        let bit = Math.round(Math.random())
                        object.truthTable.array[ i ] = bit
                        object.truthTable.array[i+4] = bit

                        object.truthTable.assoc[assocify(i)]   = bit
                        object.truthTable.assoc[assocify(i+4)] = bit
                    }
                    for (let i = 8; i < 12; i++) {
                        let bit = Math.round(Math.random())
                        object.truthTable.array[ i ] = bit
                        object.truthTable.array[i+4] = bit

                        object.truthTable.assoc[assocify(i)]   = bit
                        object.truthTable.assoc[assocify(i+4)] = bit
                    }
                    break
                }
                case 3: { // Фиктивная T
                    for (let i = 0; i < 8; i++) {
                        let bit = Math.round(Math.random())
                        object.truthTable.array[ i ] = bit
                        object.truthTable.array[i+8] = bit

                        object.truthTable.assoc[assocify(i)]   = bit
                        object.truthTable.assoc[assocify(i+4)] = bit
                    }
                    break
                }
            }
        }
    }
    object.dummy = find_dummy(object.truthTable.array)
    return object
}

/*
* Функция поиска фиктивных переменных в массиве.
* Принимает массив значний функции
* Возвращает массив [t,x,y,z], где на месте буквы стоит булевое true или false
* */
var find_dummy = function (array) {
    half_array = 8
    // [t, x, y, z]
    dummy = [true, true, true, true]
    //Проверяем фиктивность z
    for (var i = 0; i < half_array; i++){
        j = i*2
        if (array[j+1] != array[j])
            dummy[3] = false
    }
    //Проверяем фиктивность y
    for (var i = 0; i < 16; i+=4){
        for (var j = 0; j < 2; j++){
            if (array[i+j] != array[i+j+2])
                dummy[2] = false
        }
    }
    // Проверяем фиктивность х
    for (let i = 0; i < 4; i++)
        if (array[ i ] != array[i+4])
            dummy[1] = false
    for (let i = 8; i < 12; i++)
        if (array[ i ] != array[i+4])
            dummy[1] = false

    // Проверяем фиктивноасть t
    for (let i = 0; i < 8; i++) {
        if (array[i] != array [i+8])
            dummy[0] = false
    }

    return dummy
}

var generate = function (cb) {
    operands    = ['X', 'Y', 'Z', 'T']
    operators   = ['and', 'or', 'xor', 'implies']
    n_operands = 7
    var callbacks = 0
    var result = "("
    let object = {
        expression: "",
        truthTable: {
            array: [],
            assoc: {
                '0000': 2, '0001': 2,
                '0010': 2, '0011': 2,
                '0100': 2, '0101': 2,
                '0110': 2, '0111': 2,
                '1000': 2, '1001': 2,
                '1010': 2, '1011': 2,
                '1100': 2, '1101': 2,
                '1110': 2, '1111': 2
            },
            image: ""
        },
        pdnf: [],
        dnf: {},
        dummy: {}
    }

    function A(){
        callbacks++;
        if (callbacks == 2)
            cb(object)
    }

    for (i=0; i<n_operands*2-1; i++){
        if (i % 2){
            r = Math.ceil(Math.random()*operators.length-1)
            result += operators[r]+" "
        } else {
            not = Math.round(Math.random()) ? "not " : ""
            r = Math.ceil(Math.random()*operands.length-1)
            result += not+operands[r]+" "
            if (i == 6)
                result += ") "
        }
    }
    console.log(result)
    for (i=0; i<operands.length; i++){
        if (!result.includes(operands[i])){
            return generate(cb)
        }
    }

    wolfram.query("truth table "+result, function (err, data) {
        if (err) {
            cb(err);
            console.log(err)
            return;
        }
        try{
            row = data[1].subpods[0].text.split("\n")
        } catch (e){
            console.log(e)
            return false
        }

        object.truthTable.image = data[1].subpods[0].image
        var k = 0 // Возрастающая переменная для сохранения в ассоц массив
        for (i=row.length-1; i>0; i--) {
            var j = ((row.length - 1) - i >>> 0).toString(2);
            var disjunt = ""
            var n = k.toString(2);
            n="0000".substr(n.length)+n;
            if (row[i].slice(-2).trim() == "T") {
                object.truthTable.assoc[n] = 1
                object.truthTable.array.push(1)
                switch (j.length){
                    case 1:{
                        disjunt = "!t!x!y"
                        disjunt += parseInt(j) ? "z" : "!z"
                        break
                    }
                    case 2: {
                        disjunt = "!t!x"
                        disjunt += parseInt(j[0]) ? "y" : "!y"
                        disjunt += parseInt(j[1]) ? "z" : "!z"
                        break
                    }
                    case 3: {
                        disjunt = "!t"
                        disjunt += parseInt(j[0]) ? "x" : "!x"
                        disjunt += parseInt(j[1]) ? "y" : "!y"
                        disjunt += parseInt(j[2]) ? "z" : "!z"
                        break
                    }
                    case 4: {
                        disjunt += parseInt(j[0]) ? "t" : "!t"
                        disjunt += parseInt(j[1]) ? "x" : "!x"
                        disjunt += parseInt(j[2]) ? "y" : "!y"
                        disjunt += parseInt(j[3]) ? "z" : "!z"
                    }
                }
                object.pdnf.push(disjunt)
            } else {
                object.truthTable.assoc[n] = 0
                object.truthTable.array.push(0)
            }
            k++
        }
        if (object.truthTable.array.length != 16)
            return generate(cb)
        object.expression = row[i].slice(16)
        //object.dummy = find_fic(object.truthTable.array)
        A()
    });

    wolfram.query("dnf "+result, function (err, data) {
        if (err) {
            cb(err);
            console.log(err);
            return;
        }

        if (!data[0].subpods[1])
            return generate(cb)
        if (!data[0].subpods[1].text.includes("AND"))
            return generate(cb)
        object.dnf = data[0].subpods[1]
        object.dnf.arr = object.dnf.text.split(" OR  ")
        for (i = 0; i < object.dnf.arr.length; i++){
            //Преобразуем все энды в пустоту
            object.dnf.arr[i] = object.dnf.arr[i].replace(/ AND  /g, "");
            //Преобразуем (NOT X) в !x
            object.dnf.arr[i] = object.dnf.arr[i].replace(/\(NOT (\w)\)/g,"!$1").toLowerCase()
            object.dnf.arr[i] = object.dnf.arr[i].replace(/\(|\)/g,"")
        }

        A()
    });
}

module.exports.generate = generate
module.exports.generate_dummy = generate_dummy